# 交易

### 简介

根据比特币系统 的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和 通过验证

### 交易的输入输出

比特币交易中的基础构建单元是交易输出，交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。比特币完整节点跟踪所有可找到的和可使用的输出，称为“未花费的交易输出”（unspent transaction outputs)即UTXO，所有UTXO的集合被称为UTXO集，目前有数百万个UTXO。当新的UTXO被创建，UTXO集就会变大，当UTXO被消耗时，UTXO集就会缩小。每个交易都代表UTXO集的变化（状态转换）

从交易的输出与输入链角度来看，有一个例外，即存在一种被称为“币基交易”（Coinbase Transcation)的特殊交易，它是每个区块中的第一笔交易，这种交易的存在的原因是作为对挖矿的奖励，创造出全新的可花费比特币用来支付给矿工。

### 交易输出

##### 交易输出组成

1. 一定量的比特币，面值为聪；
2. 确定花费输出所需条件的加密难题，加密难题也称脚本公钥（scriptPubKey)或锁定脚本或见证脚本

##### 交易输出序列化

| Size      | Field               | Description                                                 |
| --------- | ------------------- | ----------------------------------------------------------- |
| 8bytes    | Amount              | Bitcoin value                                               |
| 1-9 bytes | Locking-Script Size | Locking-Script length in bytes                              |
| Variable  | Locking-Script      | A script defining the conditions needed to spend the output |



### 交易输入

##### 交易输入包含

1. 一个交易ID，用来引用包含正在使用的UTXO的交易
2. 一个输出索引(vout),用于标识来自该交易的哪个UTXO被引用（第一个为零）
3. 一个scriptSig(解锁脚本)，满足放置在UTXO上的条件，解锁它用于支出
4. 一个序列号

##### 交易输入序列号

| Size      | Field                   |                                                              |
| --------- | ----------------------- | ------------------------------------------------------------ |
| 32 bytes  | Transaction Hash        | Pointer to the transaction containing the UTXO to be spent   |
| 4 bytes   | Output index            | The index number of the UTXO to be spent; first one is 0     |
| 1-9 bytes | Unlocking-Script length | Unlocking-Script length in bytes                             |
| Variable  | Unlocking-Script        | a script that fulfills the conditions of the UTXO locking script |
| 4 bytes   | Sequence Number         | Used for locktime or disabled                                |

### 交易费

大多数交易包含交易费，这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。

矿工会依据许多不同的标准对交易进行优先级排序，包括费用，他们甚至可能在某些特定情况下免费处理交易。但大多数情况下，交易费影响处理优先级，这意味着足够费用的交易会更可能被打包进下一个挖出的区块中，反之交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则，在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，而且没有交易费也可能被处理，但交易费将他提高处理优先级。

### 比特币交易脚本和脚本语言

当一笔交易被验证时，每一个输入值中的解锁脚本与其对应的锁定脚本同时（互不干扰地）执行，以确定这笔交易是否满足支付条件。

脚本是一种非常简单的语言，被设计为可在执行范围上有限制，可在一些硬件上执行，可能与嵌入式装置一样简单。

交易是以P2PKH(Pay to Public Key Hash)脚本。其实，锁定脚本可以被编写成表达各种复杂的情况。

#####  图灵非完备性

比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式-除了有条件的流控制以外，没有循环或复杂流控制能力。这样就保证了脚本语言的图灵非完备性，这意味着脚本有限的复杂性和可预见的执行次数。不会引起对比特币网络的“拒绝服务“攻击。

##### 去中心化验证

比特币交易脚本语言是没有中心化主体的，没有任何中心主体能凌驾于脚本之上，也没有中心主体会在脚本被执行后对其进行保存。所有执行脚本所需信息都已包含在脚本中。

##### 脚本构建（锁定与解锁）

比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。

锁定脚本是一个放置在输出上面的花费条件：它指定了今后花费这笔输出所必须要满足的条件。

解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，它将允许输出被消费。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包生成的数字签名。

每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。然后依次执行解锁和锁定脚本。如果解锁脚本满足锁定脚本条件，则输入有效，所有输入都是独立验证的，作为交易总体验证的一部分。

尽管绝大多数解锁脚本都指向一个公钥哈希值（本质上就是比特币地址），因此如果想要使用资金则需要验证所有权，但脚本本身并不需要如此复杂。任何解锁和锁定脚本的组合如果结果为真，则为有效

例如：

锁定脚本：3 OP_ADD 5 OP_EQUAL

解锁脚本：2

如果堆栈顶部的结果显示为TRUE（0x01), 即为任何非零值，或脚本执行后堆栈为空情形，则交易有效。如果堆栈顶部的结果显示为FALSE，或脚本执行被操作码明确禁止，如OP_VERIFY, OP_RETURN或有条件终止如OP_ENDIF, 则交易无效。

##### P2PKH(Pay to Public Key Hash)

比特币网络处理的大多数交易花费的都是由“付款至公钥哈希”（P2PKH)脚本锁定的输出，这些输出都含有一个锁定脚本，将输入锁定为一个公钥哈希值，即我们常说的比特币地址。由P2PKH脚本锁定的输出可以通过提供一个公钥和由相应私钥创建的数字签名来解锁。

锁定脚本：OP_DUP OP_HASH160 <public key hash> OP_EQUALVERIFY OP_CHECKSIG

解锁脚本：<Signature> <public key>

##### 数字签名

数字签名在不揭示私钥的情况下提供私钥的所有权证明

数字签名有三种用途：

1. 签名证明私钥的所有者，已经授权支出这些资金
2. 授权证明是不可否认的
3. 签名证明交易（或交易的具体部分）在签名之后没有也不能被任何人修改。

##### 数字签名如何工作

数字签名有两部分组成：

1. 使用私钥从消息创建签名的算法
2. 允许任何人验证签名的算法，给定消息和公钥

签名：Sig = sig(hash(m), da)

